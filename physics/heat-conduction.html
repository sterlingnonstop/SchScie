<!DOCTYPE html>
<html lang="zh-Hant" data-bs-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>固體熱傳導模擬 - 國中數理互動學習</title>
    <meta name="description" content="互動式熱傳導模擬，觀察粒子碰撞與能量傳遞過程">
    <!-- Bootstrap 5.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome 6 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Skip link */
        .skip-link {position:absolute;left:-1000px;top:0;background:#000;color:#fff;padding:.5rem 1rem;z-index:1000;}
        .skip-link:focus {left:0;}
        
        /* Focus visibility */
        :focus-visible {outline:3px solid #ff9800;outline-offset:2px;}
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background-color: var(--bs-body-bg);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }
        
        .canvas-container {
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.1);
            background-color: var(--bs-body-bg);
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
            aspect-ratio: 4/3;
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        /* Range slider 自訂樣式 */
        input[type=range].form-range {
            height: 30px;
            cursor: pointer;
        }
        
        input[type=range].form-range::-webkit-slider-thumb {
            height: 24px;
            width: 24px;
            background: #fff;
            border: 2px solid #dc3545;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type=range].form-range::-webkit-slider-runnable-track {
            height: 6px;
            background: linear-gradient(to right, #0d6efd, #dc3545);
            border-radius: 4px;
        }
        
        input[type=range].form-range::-moz-range-thumb {
            height: 24px;
            width: 24px;
            background: #fff;
            border: 2px solid #dc3545;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        input[type=range].form-range::-moz-range-track {
            height: 6px;
            background: linear-gradient(to right, #0d6efd, #dc3545);
            border-radius: 4px;
        }
        
        .temp-badge {
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
        }
        
        @media (max-width: 768px) {
            .canvas-container {
                aspect-ratio: 1/1;
            }
        }
    </style>
</head>
<body>

    <a href="#main" class="skip-link">跳到主內容</a>
    
    <!-- 導航列 -->
    <nav class="navbar navbar-expand-lg bg-body-tertiary position-fixed top-0 w-100" style="z-index: 1000;">
        <div class="container-fluid">
            <a class="navbar-brand" href="../index.html" aria-label="返回首頁">
                <i class="fa-solid fa-house" aria-hidden="true"></i>
                <span class="ms-2">首頁</span>
            </a>
            <button id="themeToggle" class="btn btn-outline-secondary" type="button" aria-pressed="false" aria-label="切換深淺主題">
                <i class="fa-solid fa-circle-half-stroke" aria-hidden="true"></i>
            </button>
        </div>
    </nav>

    <main id="main" class="container-fluid" style="margin-top: 70px; max-width: 1400px;" tabindex="-1">
        <div class="row g-4">
            
            <!-- 左側：模擬畫布 -->
            <div class="col-12 col-lg-8">
                <div class="card h-100">
                    <div class="card-body p-3 p-md-4">
                        <div class="canvas-container border border-2 border-secondary-subtle">
                            <canvas id="simCanvas" role="img" aria-label="熱傳導粒子動畫模擬"></canvas>
                            
                            <!-- 標籤：左物體 -->
                            <div class="position-absolute bottom-0 start-25 translate-middle-x mb-2 badge bg-danger bg-opacity-10 text-danger border border-danger fs-6 px-3 py-2" style="pointer-events: none;">
                                熱源物體 (左)
                            </div>
                            <!-- 標籤：右物體 -->
                            <div class="position-absolute bottom-0 end-25 translate-middle-x mb-2 badge bg-primary bg-opacity-10 text-primary border border-primary fs-6 px-3 py-2" style="pointer-events: none;">
                                傳導物體 (右)
                            </div>

                            <!-- 溫度顯示 -->
                            <div class="position-absolute top-0 start-0 m-2 bg-white bg-opacity-75 rounded px-2 py-1 temp-badge border">
                                左側溫度: <span id="leftTempDisplay" class="fw-bold text-danger">25</span>°C
                            </div>
                            <div class="position-absolute top-0 end-0 m-2 bg-white bg-opacity-75 rounded px-2 py-1 temp-badge border">
                                右側平均: <span id="rightTempDisplay" class="fw-bold text-primary">25</span>°C
                            </div>
                        </div>
                        <p class="small text-muted mt-3 mb-0">
                            <i class="fa-solid fa-circle-info" aria-hidden="true"></i>
                            模擬說明：左側物體受滑桿控制，熱能會經由介面傳導至右側物體。
                        </p>
                    </div>
                </div>
            </div>

            <!-- 右側：控制面板 -->
            <div class="col-12 col-lg-4">
                <div class="card h-100">
                    <div class="card-body p-3 p-md-4">
                        <h1 class="h3 card-title mb-3">
                            <i class="fa-solid fa-fire" aria-hidden="true"></i>
                            熱傳導模擬
                        </h1>
                        <p class="card-text small mb-4">
                            觀察兩個緊鄰的固體。當左邊物體溫度升高振動變快時，透過 <strong class="text-primary">粒子碰撞</strong> 將能量傳遞給右邊的粒子。
                        </p>

                        <!-- 即時狀態通知 -->
                        <div id="statusRegion" class="visually-hidden" aria-live="polite" aria-atomic="true">初始化中</div>

                        <!-- 溫度控制 -->
                        <div class="card bg-danger bg-opacity-10 border-danger mb-4">
                            <div class="card-body">
                                <label for="heatSlider" class="form-label fw-semibold text-danger d-flex justify-content-between align-items-center mb-3">
                                    <span>設定左側熱源溫度</span>
                                </label>
                                <input type="range" class="form-range" id="heatSlider" 
                                       min="-273" max="500" value="25" step="1"
                                       aria-valuemin="-273" aria-valuemax="500" aria-valuenow="25"
                                       aria-label="調整左側熱源溫度">
                                <div class="d-flex justify-content-between small text-secondary mt-2">
                                    <span>-273°C</span>
                                    <span>500°C</span>
                                </div>
                            </div>
                        </div>

                        <!-- 控制按鈕 -->
                        <button id="resetBtn" class="btn btn-primary w-100 mb-4" type="button">
                            <i class="fa-solid fa-rotate-right" aria-hidden="true"></i>
                            重置右側溫度 (冷卻)
                        </button>

                        <!-- 快捷鍵說明 -->
                        <div class="mb-4">
                            <button class="btn btn-outline-info btn-sm w-100" type="button" 
                                    data-bs-toggle="collapse" data-bs-target="#shortcutHelp" 
                                    aria-expanded="false" aria-controls="shortcutHelp">
                                <i class="fa-solid fa-keyboard" aria-hidden="true"></i> 快捷鍵說明
                            </button>
                            <div id="shortcutHelp" class="collapse mt-2">
                                <div class="card card-body small">
                                    <ul class="mb-0" aria-label="快捷鍵清單">
                                        <li><kbd>R</kbd>：重置右側溫度</li>
                                        <li><kbd>← / →</kbd>：微調溫度 (±10°C)</li>
                                        <li><kbd>Tab</kbd>：切換焦點</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- 理論說明 Accordion -->
                        <div class="accordion" id="theoryAccordion">
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingConcept">
                                    <button class="accordion-button collapsed" type="button" 
                                            data-bs-toggle="collapse" data-bs-target="#panelConcept" 
                                            aria-expanded="false" aria-controls="panelConcept">
                                        觀察重點
                                    </button>
                                </h2>
                                <div id="panelConcept" class="accordion-collapse collapse" 
                                     aria-labelledby="headingConcept" data-bs-parent="#theoryAccordion">
                                    <div class="accordion-body small">
                                        <ul class="mb-0">
                                            <li>右側粒子是不是靠近介面的先開始動？</li>
                                            <li>這過程需要時間嗎？(熱傳導速率)</li>
                                            <li>最終兩邊溫度會如何？(熱平衡)</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="headingTheory">
                                    <button class="accordion-button collapsed" type="button" 
                                            data-bs-toggle="collapse" data-bs-target="#panelTheory" 
                                            aria-expanded="false" aria-controls="panelTheory">
                                        理論說明
                                    </button>
                                </h2>
                                <div id="panelTheory" class="accordion-collapse collapse" 
                                     aria-labelledby="headingTheory" data-bs-parent="#theoryAccordion">
                                    <div class="accordion-body small">
                                        <p><strong>熱傳導</strong>是物質內部或不同物質接觸時，高溫處的粒子將動能傳遞給低溫處粒子的過程。</p>
                                        <p>在固體中，粒子只能在平衡位置附近振動，透過連續碰撞傳遞能量。溫度越高，粒子振動越劇烈。</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
    <!-- Bootstrap JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // ===== 主題切換功能 =====
        function initThemeToggle(btn){
            function setTheme(t){
                document.documentElement.setAttribute('data-bs-theme',t);
                localStorage.setItem('theme',t);
                btn.setAttribute('aria-pressed', t==='dark');
            }
            const stored = localStorage.getItem('theme');
            if(stored){setTheme(stored);} 
            else if(window.matchMedia('(prefers-color-scheme: dark)').matches){setTheme('dark');}
            btn.addEventListener('click',()=>{
                const cur=document.documentElement.getAttribute('data-bs-theme')||'light';
                setTheme(cur==='light'?'dark':'light');
            });
        }
        initThemeToggle(document.getElementById('themeToggle'));

        // ===== Live Region 助手 =====
        function createLiveRegion(id, {interval=200}={}){
            const el = document.getElementById(id);
            let last = 0; let pending;
            return function announce(msg){
                const now = performance.now();
                if(now - last < interval){ pending = msg; return; }
                el.textContent = msg; last = now; pending = undefined;
                setTimeout(()=>{ 
                    if(pending){ 
                        el.textContent = pending; 
                        last = performance.now(); 
                        pending = undefined; 
                    }
                }, interval);
            };
        }
        const announceStatus = createLiveRegion('statusRegion');

        // ===== 鍵盤快捷鍵 =====
        document.addEventListener('keydown', e => {
            if(e.target.tagName === 'INPUT') return; // 避免干擾輸入
            
            if(e.key === 'r' || e.key === 'R'){
                e.preventDefault();
                document.getElementById('resetBtn').click();
            }
            if(e.key === 'ArrowLeft'){
                e.preventDefault();
                const slider = document.getElementById('heatSlider');
                slider.value = Math.max(parseInt(slider.min), parseInt(slider.value) - 10);
                slider.dispatchEvent(new Event('input'));
            }
            if(e.key === 'ArrowRight'){
                e.preventDefault();
                const slider = document.getElementById('heatSlider');
                slider.value = Math.min(parseInt(slider.max), parseInt(slider.value) + 10);
                slider.dispatchEvent(new Event('input'));
            }
        });

        // ===== 模擬主程式 =====
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('heatSlider');
        const resetBtn = document.getElementById('resetBtn');
        const leftTempDisplay = document.getElementById('leftTempDisplay');
        const rightTempDisplay = document.getElementById('rightTempDisplay');
        
        // 模擬參數
        let particleRadius = 8; 
        let particles = []; // 2D Array: particles[row][col]
        let rows = 6;
        let cols = 14; // 偶數，左右各半
        
        let targetLeftTemp = 25; // 滑桿設定的目標溫度
        let time = 0; 
        
        // 物理常數
        const CONDUCTION_RATE = 0.08; // 熱傳導係數 (0.01~0.1)
        const SOURCE_HEATING_RATE = 0.15; // 左側加熱速度

        // 調整畫布與粒子大小
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            const minDim = Math.min(canvas.width, canvas.height);
            particleRadius = Math.max(4, Math.floor(minDim / 30)); 
            initParticles(); 
        }
        window.addEventListener('resize', resizeCanvas);

        class SolidParticle {
            constructor(baseX, baseY, isLeft) {
                this.baseX = baseX; 
                this.baseY = baseY;
                this.x = baseX;
                this.y = baseY;
                this.isLeft = isLeft; // 標記屬於左邊還是右邊物體
                
                // 初始溫度
                this.temp = isLeft ? targetLeftTemp : 25; 
                
                this.phaseX = Math.random() * Math.PI * 2;
                this.phaseY = Math.random() * Math.PI * 2;
                this.freqScale = 0.8 + Math.random() * 0.4;
            }

            updatePosition(time) {
                // 根據當前溫度計算振幅與速度
                let tNorm = (this.temp + 273) / (500 + 273);
                if (tNorm < 0) tNorm = 0;
                
                // 縮放係數 (RWD)
                const scaleFactor = canvas.width / 400;

                const amplitude = tNorm * 12 * scaleFactor;
                const speed = 0.05 + tNorm * 0.2;

                if (this.temp <= -273) {
                    this.x = this.baseX;
                    this.y = this.baseY;
                } else {
                    this.x = this.baseX + Math.sin(time * speed * this.freqScale + this.phaseX) * amplitude;
                    this.y = this.baseY + Math.cos(time * speed * this.freqScale + this.phaseY) * amplitude;
                }
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, particleRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.getColor();
                ctx.fill();
                
                // 高光
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.beginPath();
                ctx.arc(this.x - particleRadius*0.25, this.y - particleRadius*0.25, particleRadius/3, 0, Math.PI * 2);
                ctx.fill();
            }

            getColor() {
                const t = this.temp;
                if (t <= -273) return 'rgb(50, 50, 80)';
                
                let r, g, b;
                if (t < 0) {
                    const ratio = (t + 273) / 273; 
                    r = Math.floor(50 * (1-ratio));
                    g = Math.floor(50 * (1-ratio) + 100 * ratio);
                    b = Math.floor(80 * (1-ratio) + 255 * ratio);
                } else if (t < 100) {
                    const ratio = t / 100;
                    r = Math.floor(255 * ratio);
                    g = Math.floor(100 * (1-ratio) + 50 * ratio);
                    b = Math.floor(255 * (1-ratio) + 50 * ratio);
                } else {
                    const ratio = (t - 100) / 400; // max 500
                    r = 255;
                    g = Math.floor(50 + 205 * ratio); // 變黃/白
                    b = Math.floor(50 + 205 * ratio);
                }
                return `rgb(${r}, ${g}, ${b})`;
            }
        }

        function initParticles() {
            particles = [];
            // 計算間距與邊界
            const paddingX = canvas.width * 0.1;
            const paddingY = canvas.height * 0.15;
            const availWidth = canvas.width - paddingX * 2;
            const availHeight = canvas.height - paddingY * 2;
            
            // 兩個物體中間留一個小縫隙，但在邏輯上是相連的
            const gapSize = particleRadius * 2; 
            const totalWidth = availWidth - gapSize;
            
            // 每個粒子的寬度空間
            const stepX = totalWidth / (cols - 1); // 減1是因為最後一個點的位置
            const stepY = availHeight / (rows - 1);

            for(let r = 0; r < rows; r++) {
                let rowParticles = [];
                for(let c = 0; c < cols; c++) {
                    let isLeft = c < (cols / 2);
                    
                    // 計算 X 位置：如果是右邊物體，要加上縫隙寬度
                    let x = paddingX + c * stepX;
                    if (!isLeft) {
                        x += gapSize;
                    }
                    
                    let y = paddingY + r * stepY;
                    
                    rowParticles.push(new SolidParticle(x, y, isLeft));
                }
                particles.push(rowParticles);
            }
        }

        // --- 核心演算法：熱傳導計算 ---
        function simulateHeatTransfer() {
            // 為了讓傳導平滑，我們建立一個暫存的溫度陣列 (Next State)
            // 避免在同一個 Frame 中因為計算順序造成偏差
            let nextTemps = [];

            for (let r = 0; r < rows; r++) {
                nextTemps[r] = [];
                for (let c = 0; c < cols; c++) {
                    const p = particles[r][c];
                    
                    if (p.isLeft) {
                        // 左邊物體：強制趨近於滑桿設定溫度 (熱源)
                        // 使用線性插值 (Lerp) 模擬加熱過程，而非瞬間變換
                        let diff = targetLeftTemp - p.temp;
                        nextTemps[r][c] = p.temp + diff * SOURCE_HEATING_RATE;
                    } else {
                        // 右邊物體：計算四周鄰居的平均溫度 (擴散/傳導)
                        let neighborSum = 0;
                        let count = 0;

                        // 上
                        if (r > 0) { neighborSum += particles[r-1][c].temp; count++; }
                        // 下
                        if (r < rows - 1) { neighborSum += particles[r+1][c].temp; count++; }
                        // 右
                        if (c < cols - 1) { neighborSum += particles[r][c+1].temp; count++; }
                        // 左 (關鍵：右物體最左排會讀取左物體最右排的溫度)
                        if (c > 0) { neighborSum += particles[r][c-1].temp; count++; }

                        // 自身溫度 + (鄰居平均 - 自身) * 傳導速率
                        if (count > 0) {
                            let avg = neighborSum / count;
                            let diff = avg - p.temp;
                            nextTemps[r][c] = p.temp + diff * CONDUCTION_RATE;
                        } else {
                            nextTemps[r][c] = p.temp;
                        }
                    }
                }
            }

            // 更新所有粒子的溫度
            let rightTotalTemp = 0;
            let rightCount = 0;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    particles[r][c].temp = nextTemps[r][c];
                    
                    if (!particles[r][c].isLeft) {
                        rightTotalTemp += particles[r][c].temp;
                        rightCount++;
                    }
                }
            }

            // 更新 UI 顯示
            if (rightCount > 0) {
                rightTempDisplay.textContent = Math.round(rightTotalTemp / rightCount);
            }
        }

        function drawInterface() {
            // 畫出中間的分隔線
            const midIndex = cols / 2;
            // 找出左邊最後一顆和右邊第一顆的中間點
            if (particles.length > 0 && particles[0].length > midIndex) {
                const leftP = particles[0][midIndex-1];
                const rightP = particles[0][midIndex];
                const midX = (leftP.baseX + rightP.baseX) / 2;
                
                ctx.beginPath();
                ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
                ctx.setLineDash([5, 5]);
                ctx.moveTo(midX, particles[0][0].baseY - 20);
                ctx.lineTo(midX, particles[rows-1][0].baseY + 20);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. 計算熱傳導
            simulateHeatTransfer();

            // 2. 繪製介面輔助線
            drawInterface();

            // 3. 更新位置並繪製粒子
            for (let r = 0; r < rows; r++) {
                // 畫橫向連結線 (視覺輔助)
                ctx.beginPath();
                ctx.strokeStyle = "rgba(200, 200, 200, 0.2)";
                ctx.moveTo(particles[r][0].x, particles[r][0].y);
                for (let c = 1; c < cols; c++) {
                    // 如果跨越中間，線條淡一點或不畫，這裡我們畫淡一點表示接觸
                    if (c === cols/2) {
                         ctx.stroke();
                         ctx.beginPath(); // 斷開
                         ctx.moveTo(particles[r][c].x, particles[r][c].y);
                    } else {
                        ctx.lineTo(particles[r][c].x, particles[r][c].y);
                    }
                }
                ctx.stroke();

                for (let c = 0; c < cols; c++) {
                    particles[r][c].updatePosition(time);
                    particles[r][c].draw(ctx);
                }
            }

            time += 1;
            requestAnimationFrame(animate);
        }

        // --- 事件監聽 ---
        slider.addEventListener('input', (e) => {
            targetLeftTemp = parseInt(e.target.value);
            leftTempDisplay.textContent = targetLeftTemp;
            slider.setAttribute('aria-valuenow', targetLeftTemp);
            announceStatus(`左側溫度設為 ${targetLeftTemp} 度`);
        });

        resetBtn.addEventListener('click', () => {
            // 重置右邊物體溫度為 25 度
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (!particles[r][c].isLeft) {
                        particles[r][c].temp = 25;
                    }
                }
            }
            rightTempDisplay.textContent = 25;
            announceStatus('已重置右側溫度為 25 度');
        });

        // 初始化
        announceStatus('熱傳導模擬已載入');
        setTimeout(() => {
            resizeCanvas(); 
            animate();
        }, 100);

    </script>
</body>
</html>