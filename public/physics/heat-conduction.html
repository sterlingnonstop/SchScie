<!DOCTYPE html>
<html lang="zh-Hant" data-bs-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>固體熱傳導模擬 - 國中自然科學模擬動畫</title>
    <meta name="description" content="互動式熱傳導模擬，觀察粒子碰撞與能量傳遞過程">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
    <link rel="stylesheet" href="../assets/css/common.css" />
    <link rel="stylesheet" href="../assets/css/accessibility.css" />
    <style>
        /* Page-specific styles */
        .canvas-container {
            /* Using aspect-ratio from common.css */
            min-height: 400px; /* Provide a minimum height */
        }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        input[type=range].form-range::-webkit-slider-thumb {
            border: 2px solid #dc3545;
        }
        
        input[type=range].form-range::-moz-range-thumb {
            border: 2px solid #dc3545;
        }
        
        .temp-badge {
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
        }
    </style>
</head>
<body>

    <a href="#main" class="skip-link">跳到主內容</a>
    
    <!-- Navbar Container -->
    <div id="navbarContainer"></div>

    <main id="main" class="container-fluid my-4 flex-grow-1" tabindex="-1">
        <div class="row g-4">
            
            <!-- Left side: Simulation Canvas -->
            <div class="col-12 col-lg-8">
                <div class="card h-100">
                    <div class="card-body p-3 p-md-4 d-flex flex-column">
                        <div class="canvas-container border border-2 border-secondary-subtle flex-grow-1">
                            <canvas id="simCanvas" role="img" aria-label="熱傳導粒子動畫模擬"></canvas>
                            
                            <!-- Labels -->
                            <div class="position-absolute bottom-0 start-25 translate-middle-x mb-2 badge bg-danger bg-opacity-10 text-danger border border-danger fs-6 px-3 py-2" style="pointer-events: none;">
                                熱源物體 (左)
                            </div>
                            <div class="position-absolute bottom-0 end-25 translate-middle-x mb-2 badge bg-primary bg-opacity-10 text-primary border border-primary fs-6 px-3 py-2" style="pointer-events: none;">
                                傳導物體 (右)
                            </div>

                            <!-- Temperature Displays -->
                            <div class="position-absolute top-0 start-0 m-2 bg-white bg-opacity-75 rounded px-2 py-1 temp-badge border">
                                左側溫度: <span id="leftTempDisplay" class="fw-bold text-danger">25</span>°C
                            </div>
                            <div class="position-absolute top-0 end-0 m-2 bg-white bg-opacity-75 rounded px-2 py-1 temp-badge border">
                                右側平均: <span id="rightTempDisplay" class="fw-bold text-primary">25</span>°C
                            </div>
                        </div>
                        <p class="small text-muted mt-3 mb-0">
                            <i class="fa-solid fa-circle-info" aria-hidden="true"></i>
                            模擬說明：左側物體受滑桿控制，熱能會經由介面傳導至右側物體。
                        </p>
                    </div>
                </div>
            </div>

            <!-- Right side: Control Panel -->
            <div class="col-12 col-lg-4">
                <div class="card h-100">
                    <div class="card-body p-3 p-md-4">
                        <h1 class="h3 card-title mb-3">
                            <i class="fa-solid fa-fire" aria-hidden="true"></i>
                            熱傳導模擬
                        </h1>
                        <p class="card-text small mb-4">
                            觀察兩個緊鄰的固體。當左邊物體溫度升高振動變快時，透過 <strong class="text-primary">粒子碰撞</strong> 將能量傳遞給右邊的粒子。
                        </p>

                        <div class="card bg-danger bg-opacity-10 border-danger mb-4">
                            <div class="card-body">
                                <label for="heatSlider" class="form-label fw-semibold text-danger d-flex justify-content-between align-items-center mb-3">
                                    <span>設定左側熱源溫度</span>
                                </label>
                                <input type="range" class="form-range" id="heatSlider" 
                                       min="-273" max="500" value="25" step="1"
                                       aria-label="調整左側熱源溫度">
                                <div class="d-flex justify-content-between small text-secondary mt-2">
                                    <span>-273°C</span>
                                    <span>500°C</span>
                                </div>
                            </div>
                        </div>

                        <button id="resetBtn" class="btn btn-primary w-100 mb-4" type="button">
                            <i class="fa-solid fa-rotate-right" aria-hidden="true"></i>
                            重置系統溫度
                        </button>

                        <div class="mb-4">
                            <button class="btn btn-outline-info btn-sm w-100" type="button" 
                                    data-bs-toggle="collapse" data-bs-target="#shortcutHelp" 
                                    aria-expanded="false" aria-controls="shortcutHelp">
                                <i class="fa-solid fa-keyboard" aria-hidden="true"></i> 快捷鍵說明
                            </button>
                            <div id="shortcutHelp" class="collapse mt-2">
                                <div class="card card-body small">
                                    <ul class="mb-0" aria-label="快捷鍵清單">
                                        <li><kbd>R</kbd>：重置右側溫度</li>
                                        <li><kbd>← / →</kbd>：微調溫度 (±10°C)</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <div class="accordion" id="theoryAccordion">
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" 
                                            data-bs-toggle="collapse" data-bs-target="#panelConcept" 
                                            aria-expanded="false" aria-controls="panelConcept">
                                        觀察重點
                                    </button>
                                </h2>
                                <div id="panelConcept" class="accordion-collapse collapse" data-bs-parent="#theoryAccordion">
                                    <div class="accordion-body small">
                                        <ul class="mb-0">
                                            <li>右側粒子是不是靠近介面的先開始動？</li>
                                            <li>這過程需要時間嗎？(熱傳導速率)</li>
                                            <li>最終兩邊溫度會如何？(熱平衡)</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="accordion-item">
                                <h2 class="accordion-header">
                                    <button class="accordion-button collapsed" type="button" 
                                            data-bs-toggle="collapse" data-bs-target="#panelTheory" 
                                            aria-expanded="false" aria-controls="panelTheory">
                                        理論說明
                                    </button>
                                </h2>
                                <div id="panelTheory" class="accordion-collapse collapse" data-bs-parent="#theoryAccordion">
                                    <div class="accordion-body small">
                                        <p><strong>熱傳導</strong>是物質內部或不同物質接觸時，高溫處的粒子將動能傳遞給低溫處粒子的過程。</p>
                                        <p>在固體中，粒子只能在平衡位置附近振動，透過連續碰撞傳遞能量。溫度越高，粒子振動越劇烈。</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer Container -->
    <div id="footerContainer"></div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    
    <script type="module">
        import { initThemeToggle } from '../assets/js/theme.js';
        import { loadNavigation } from '../assets/js/navigation.js';
        import { createLiveRegion, KeyboardManager } from '../assets/js/a11y.js';

        async function initPage() {
            await loadNavigation({
                baseUrl: '..',
                navbarPath: '../assets/templates/navbar.html',
                footerPath: '../assets/templates/footer.html'
            });

            initThemeToggle();
            
            window.liveRegion = createLiveRegion({ id: 'simLiveRegion', throttle: 300 }).announce;

            const keyboardManager = new KeyboardManager();
            const slider = document.getElementById('heatSlider');
            
            keyboardManager.register('r', () => document.getElementById('resetBtn').click());
            keyboardManager.register('R', () => document.getElementById('resetBtn').click());

            keyboardManager.register('ArrowLeft', () => {
                slider.value = Math.max(parseInt(slider.min), parseInt(slider.value) - 10);
                slider.dispatchEvent(new Event('input', { bubbles: true }));
            });
            keyboardManager.register('ArrowRight', () => {
                slider.value = Math.min(parseInt(slider.max), parseInt(slider.value) + 10);
                slider.dispatchEvent(new Event('input', { bubbles: true }));
            });
        }
        initPage();
    </script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('simCanvas');
            const ctx = canvas.getContext('2d');
            const slider = document.getElementById('heatSlider');
            const resetBtn = document.getElementById('resetBtn');
            const leftTempDisplay = document.getElementById('leftTempDisplay');
            const rightTempDisplay = document.getElementById('rightTempDisplay');
            
            let particleRadius = 8; 
            let particles = [];
            let rows = 6;
            let cols = 14;
            let time = 0; 
            
            const CONDUCTION_RATE = 0.08;

            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;
                
                if(canvas.width === 0 || canvas.height === 0) {
                    requestAnimationFrame(resizeCanvas);
                    return;
                }

                const minDim = Math.min(canvas.width, canvas.height);
                particleRadius = Math.max(4, Math.floor(minDim / 30)); 
                initParticles(); 
            }

            class SolidParticle {
                constructor(baseX, baseY, isLeft) {
                    this.baseX = baseX; 
                    this.baseY = baseY;
                    this.x = baseX;
                    this.y = baseY;
                    this.isLeft = isLeft;
                    this.temp = 25; // Initialize all at 25C
                    this.phaseX = Math.random() * Math.PI * 2;
                    this.phaseY = Math.random() * Math.PI * 2;
                    this.freqScale = 0.8 + Math.random() * 0.4;
                }

                updatePosition(time) {
                    let tNorm = (this.temp + 273) / (500 + 273);
                    tNorm = Math.max(0, tNorm);
                    
                    const scaleFactor = canvas.width / 400;
                    const amplitude = tNorm * 12 * scaleFactor;
                    const speed = 0.05 + tNorm * 0.2;

                    if (this.temp <= -273) {
                        this.x = this.baseX;
                        this.y = this.baseY;
                    } else {
                        this.x = this.baseX + Math.sin(time * speed * this.freqScale + this.phaseX) * amplitude;
                        this.y = this.baseY + Math.cos(time * speed * this.freqScale + this.phaseY) * amplitude;
                    }
                }

                draw(ctx) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, particleRadius, 0, Math.PI * 2);
                    ctx.fillStyle = this.getColor();
                    ctx.fill();
                    
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    ctx.beginPath();
                    ctx.arc(this.x - particleRadius*0.25, this.y - particleRadius*0.25, particleRadius/3, 0, Math.PI * 2);
                    ctx.fill();
                }

                getColor() {
                    const t = this.temp;
                    if (t <= -273) return 'rgb(50, 50, 80)';
                    let r, g, b;
                    if (t < 100) {
                        const ratio = Math.max(0, (t + 273)) / (100 + 273);
                        r = Math.floor(50 * (1-ratio) + 255 * ratio);
                        g = Math.floor(80 * (1-ratio) + 100 * ratio);
                        b = Math.floor(255 * (1-ratio) + 50 * ratio);
                    } else {
                        const ratio = Math.min(1, (t - 100) / 400);
                        r = 255;
                        g = Math.floor(100 + 155 * ratio);
                        b = Math.floor(50 + 205 * ratio);
                    }
                    return `rgb(${r}, ${g}, ${b})`;
                }
            }

            function initParticles() {
                particles = [];
                const paddingX = canvas.width * 0.1;
                const paddingY = canvas.height * 0.15;
                const availWidth = canvas.width - paddingX * 2;
                const availHeight = canvas.height - paddingY * 2;
                const gapSize = particleRadius * 2; 
                const totalWidth = availWidth - gapSize;
                const stepX = totalWidth / (cols - 1);
                const stepY = availHeight / (rows - 1);

                for(let r = 0; r < rows; r++) {
                    let rowParticles = [];
                    for(let c = 0; c < cols; c++) {
                        let isLeft = c < (cols / 2);
                        let x = paddingX + c * stepX + (isLeft ? 0 : gapSize);
                        let y = paddingY + r * stepY;
                        rowParticles.push(new SolidParticle(x, y, isLeft));
                    }
                    particles.push(rowParticles);
                }
                slider.value = 25; // Ensure slider is reset too
            }

            function simulateHeatTransfer() {
                let nextTemps = particles.map(row => row.map(p => p.temp));

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        // All particles follow the same diffusion logic
                        let neighborSum = 0;
                        let count = 0;
                        if (r > 0) { neighborSum += particles[r-1][c].temp; count++; }
                        if (r < rows - 1) { neighborSum += particles[r+1][c].temp; count++; }
                        if (c < cols - 1) { neighborSum += particles[r][c+1].temp; count++; }
                        if (c > 0) { neighborSum += particles[r][c-1].temp; count++; }
                        
                        if (count > 0) {
                            let diff = (neighborSum / count) - particles[r][c].temp;
                            nextTemps[r][c] = particles[r][c].temp + diff * CONDUCTION_RATE;
                        }
                    }
                }

                let rightTotalTemp = 0;
                let rightCount = 0;
                let leftTotalTemp = 0;
                let leftCount = 0;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        particles[r][c].temp = nextTemps[r][c];
                        if (particles[r][c].isLeft) {
                            leftTotalTemp += particles[r][c].temp;
                            leftCount++;
                        } else {
                            rightTotalTemp += particles[r][c].temp;
                            rightCount++;
                        }
                    }
                }

                if (leftCount > 0) {
                    leftTempDisplay.textContent = Math.round(leftTotalTemp / leftCount);
                }
                if (rightCount > 0) {
                    rightTempDisplay.textContent = Math.round(rightTotalTemp / rightCount);
                }
            }

            function drawInterface() {
                if (particles.length > 0 && particles[0].length > cols / 2) {
                    const midIndex = cols / 2;
                    const leftP = particles[0][midIndex-1];
                    const rightP = particles[0][midIndex];
                    const midX = (leftP.baseX + rightP.baseX) / 2;
                    
                    ctx.beginPath();
                    ctx.strokeStyle = "rgba(100, 100, 100, 0.3)";
                    ctx.setLineDash([5, 5]);
                    ctx.moveTo(midX, 0);
                    ctx.lineTo(midX, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            function animate() {
                if (!ctx) return;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                simulateHeatTransfer();
                drawInterface();
                for (let row of particles) {
                    for (let p of row) {
                        p.updatePosition(time);
                        p.draw(ctx);
                    }
                }
                time += 1;
                requestAnimationFrame(animate);
            }

            slider.addEventListener('input', (e) => {
                const newTemp = parseInt(e.target.value);
                for (const p of particles.flat()) {
                    if (p.isLeft) {
                        p.temp = newTemp;
                    }
                }
                leftTempDisplay.textContent = newTemp;
                if (window.liveRegion) {
                    window.liveRegion(`左側溫度設為 ${newTemp} 度`);
                }
            });

            resetBtn.addEventListener('click', () => {
                for (const p of particles.flat()) {
                    p.temp = 25;
                }
                leftTempDisplay.textContent = 25;
                rightTempDisplay.textContent = 25;
                slider.value = 25;
                
                if (window.liveRegion) {
                    window.liveRegion('已重置系統溫度為 25 度');
                }
            });
            
            window.addEventListener('resize', resizeCanvas);
            
            // Initial Start
            resizeCanvas();
            animate();
            if (window.liveRegion) {
                window.liveRegion('熱傳導模擬已載入');
            }
        });
    </script>
</body>
</html>